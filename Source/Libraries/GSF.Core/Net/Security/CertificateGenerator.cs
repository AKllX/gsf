//******************************************************************************************************
//  SelfSignedCertificateGenerator.cs - Gbtc
//
//  Copyright © 2013, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the Eclipse Public License -v 1.0 (the "License"); you may
//  not use this file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://www.opensource.org/licenses/eclipse-1.0.php
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  12/18/2013 - Stephen C. Wills
//       Generated original version of source code.
//
//******************************************************************************************************

using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using GSF.IO;

namespace GSF.Net.Security
{
    /// <summary>
    /// The CertificateGenerator searches certificate stores for existing certificates and creates
    /// self-signed certificates if no matching certificate exists in any accessible store.
    /// It then generates a certificate file at the specified certificate path.
    /// </summary>
    public class CertificateGenerator
    {
        #region [ Members ]

        // Fields
        private string m_issuer;
        private string[] m_subjectNames;
        private StoreLocation? m_location;
        private string m_certificatePath;

        #endregion

        #region [ Properties ]

        /// <summary>
        /// Gets or sets the name of the entity issuing the certificate.
        /// </summary>
        public string Issuer
        {
            get
            {
                return (m_issuer = m_issuer ?? GetDefaultIssuer());
            }
            set
            {
                m_issuer = value;
            }
        }

        /// <summary>
        /// Gets or sets the subject names (common names)
        /// of the entity that this certificate identifies.
        /// </summary>
        public string[] SubjectNames
        {
            get
            {
                return (m_subjectNames = m_subjectNames ?? GetDefaultSubjectNames());
            }
            set
            {
                m_subjectNames = value;
            }
        }

        /// <summary>
        /// Gets or sets the location where this certificate is stored.
        /// </summary>
        public StoreLocation? Location
        {
            get
            {
                return (m_location = m_location ?? GetDefaultLocation());
            }
            set
            {
                m_location = value;
            }
        }

        /// <summary>
        /// Gets or sets the path to the certificate file
        /// that is generated by this certificate generator.
        /// </summary>
        public string CertificatePath
        {
            get
            {
                return (m_certificatePath = m_certificatePath ?? GetDefaultCertificatePath());
            }
            set
            {
                m_certificatePath = value;
            }
        }

        #endregion

        #region [ Methods ]

        /// <summary>
        /// Generates the certificate.
        /// </summary>
        /// <returns>The certificate that was generated by this certificate generator.</returns>
        public X509Certificate2 GenerateCertificate()
        {
            X509Store store;

            X509Certificate2 certificate;
            string certificatePath;
            byte[] certificateData;

            ProcessStartInfo processInfo;
            string makeCertPath;

            // Use the personal store with the given location
            store = new X509Store(StoreName.My, Location.Value);
            certificatePath = FilePath.GetAbsolutePath(CertificatePath);

            // If a certificate already exists on this path,
            // search the certificate store for an existing
            // certificate with a matching public key
            if (File.Exists(certificatePath))
            {
                try
                {
                    store.Open(OpenFlags.ReadOnly);
                    certificate = new X509Certificate2(certificatePath);

                    // If the certificate in the store does not have a private key,
                    // this system does not own the certificate so we will generate a new one
                    if (FindCertificateInStore(certificate, store).HasPrivateKey)
                        return certificate;
                }
                finally
                {
                    store.Close();
                }

                // Delete the existing file,
                // since we will be generating a new one
                File.Delete(certificatePath);
            }

            try
            {
                // Search the store for a certificate that this system
                // owns with the same issuer as the one provided
                store.Open(OpenFlags.ReadOnly);
                certificate = store.Certificates.Cast<X509Certificate2>().FirstOrDefault(cert => cert.HasPrivateKey && cert.Issuer.Split(',')[0].Trim() == "CN=" + Issuer);
                
                // If such a certificate exists, generate the certificate file and return the result
                if ((object)certificate != null)
                {
                    using (FileStream certificateStream = File.OpenWrite(certificatePath))
                    {
                        certificateData = certificate.Export(X509ContentType.Cert);
                        certificateStream.Write(certificateData, 0, certificateData.Length);
                    }

                    return new X509Certificate2(certificatePath);
                }
            }
            finally
            {
                store.Close();
            }

            // Attempt to use makecert to create a new self-signed certificate
            makeCertPath = FilePath.GetAbsolutePath("makecert.exe");

            if (File.Exists(makeCertPath))
            {
                processInfo = new ProcessStartInfo(makeCertPath);
                processInfo.Arguments = string.Format("-r -pe -n \"{1}\" -ss My -sr {2} \"{3}\"", Issuer, GetCommonNameList(), Location, certificatePath);
                processInfo.UseShellExecute = true;

                using (Process makeCertProcess = Process.Start(processInfo))
                {
                    makeCertProcess.WaitForExit();
                }
            }

            if (File.Exists(certificatePath))
                return new X509Certificate2(certificatePath);

            // All attempts to generate the certificate failed, so we must throw an exception
            throw new InvalidOperationException("Unable to generate the self-signed certificate.");
        }
        
        // Gets the list of common names to be passed to
        // makecert when generating self-signed certificates.
        private string GetCommonNameList()
        {
            return string.Join(",", new string[] { Issuer }.Concat(SubjectNames).Distinct().Select(name => "CN=" + name));
        }

        // Gets the default value for the issuer.
        private string GetDefaultIssuer()
        {
            return Dns.GetHostEntry(Dns.GetHostName()).HostName;
        }

        // Gets the default value for the subject names.
        // This uses a DNS lookup to determine the host name of the system and
        // all the possible IP addresses and aliases that the system may go by.
        private string[] GetDefaultSubjectNames()
        {
            IPHostEntry hostEntry = Dns.GetHostEntry(Dns.GetHostName());

            return hostEntry.AddressList
                .Select(address => address.ToString())
                .Concat(hostEntry.Aliases)
                .Concat(new string[] { hostEntry.HostName }).ToArray();
        }

        // Gets the default location where the certificate will be stored.
        // LocalMachine is preferred, but this will fall back on CurrentUser
        // if there is no matching certificate in the LocalMachine store or
        // the process does not have write permissions to the LocalMachine store.
        private StoreLocation GetDefaultLocation()
        {
            X509Store store;

            X509Certificate2 certificate;
            string certificatePath;

            // We'll be checking the personal local machine store for existing certificates
            store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            certificatePath = FilePath.GetAbsolutePath(CertificatePath);

            try
            {
                store.Open(OpenFlags.ReadOnly);

                // If a file already exists at the given certificate path,
                // search the store for a matching certificate that has a private key
                if (File.Exists(certificatePath))
                {
                    certificate = new X509Certificate2(certificatePath);

                    if (FindCertificateInStore(certificate, store).HasPrivateKey)
                        return StoreLocation.LocalMachine;
                }

                // Check if the store contains any certificates with a matching issuer and a private key
                if (store.Certificates.Cast<X509Certificate2>().Any(cert => cert.HasPrivateKey && cert.Issuer == Issuer))
                    return StoreLocation.LocalMachine;
            }
            catch (CryptographicException)
            {
                // In the case of a cryptographic exception, we do not have
                // permissions to access the personal local machine store,
                // so downgrade to current user
                return StoreLocation.CurrentUser;
            }
            catch (SecurityException)
            {
                // In the case of a security exception, we do not have
                // permissions to access the personal local machine store,
                // so downgrade to current user
                return StoreLocation.CurrentUser;
            }
            finally
            {
                store.Close();
            }

            try
            {
                // If we have write permissions to the
                // local machine store, we can use it anyway
                store.Open(OpenFlags.ReadWrite);
                return StoreLocation.LocalMachine;
            }
            catch (CryptographicException)
            {
                // In this case, we have read permissions but no matching
                // certificates, and we do not have write permissions so
                // we will have to downgrade to current user
                return StoreLocation.CurrentUser;
            }
            catch (SecurityException)
            {
                // In this case, we have read permissions but no matching
                // certificates, and we do not have write permissions so
                // we will have to downgrade to current user
                return StoreLocation.CurrentUser;
            }
            finally
            {
                store.Close();
            }
        }

        // Gets the default path to which the certificate file will be generated.
        private string GetDefaultCertificatePath()
        {
            return string.Format("{0}.cer", Issuer);
        }

        // Finds a certificate in the store that matches the public key of the given certificate and returns it.
        private X509Certificate2 FindCertificateInStore(X509Certificate2 certificate, X509Store store)
        {
            byte[] hash = certificate.GetCertHash();
            byte[] key = certificate.GetPublicKey();
            
            X509Certificate2 storedCertificate = store.Certificates.Cast<X509Certificate2>()
                .FirstOrDefault(cert => cert.HasPrivateKey && hash.SequenceEqual(cert.GetCertHash()) && key.SequenceEqual(cert.GetPublicKey()));

            return storedCertificate ?? certificate;
        }

        #endregion
    }
}
