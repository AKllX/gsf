<HTML>
	<HEAD>
		<TITLE>Best Practices</TITLE>
	</HEAD>
	<BODY>
		<P>
			This document lists the best practices and lessons learned from .NET projects.
		</P>
		<OL>
			<li>
				<a href="">Version References</a><p>
					Sometimes Visual Studio may get confused with conflicting versions of the same 
					library. This may be due to hard-coded paths in the project .user document. 
					Symptoms of this problem may include sudden loss of design-time property 
					settings. See <a href="http://support.microsoft.com/default.aspx?scid=kb;en-us;309815">
						http://support.microsoft.com/default.aspx?scid=kb;en-us;309815</a> for a 
					description of the issue. To ensure that the correct DLL versions are 
					referenced, do the following:<br>
					<ol>
						<li>
						close all designers in net 2003
						<li>
						change references
						<li>
						save all
						<li>
						Close your project
						<li>
						Then in your project folder, open the vbproj.user file with notepad and remove 
						all reference to janus controls in the: Settings ReferencePath section save the 
						vbproj.user file
						<li>
						re - open project
						<li>
							check version of reference - available via Properties of referenced DLL in 
							solution</li>
					</ol>
				<P></P>
			<LI>
				<a href="">Unit Testing</a><P>
					The TvaTestbed and TvaTestingLibrary namespaces provide two useful tools for 
					performing automated unit testing (and regression testing): TvaTestbed provides 
					an application that can dynamically load and execute test-class libraries, 
					while TvaTestingLibrary provides a base class named TvaTestClass that supports 
					automated unit testing via a few simple naming and calling conventions.</P>
				<p>A relatively painless way to unit-test library (DLL) code is to create a new DLL 
					project named testXXX, where XXX is the name of the class or namespace to be 
					tested. Within this project, create a class named testXXX, where XXX is the 
					name of the class to be tested. Within this class, create one or more Public 
					Subs with no arguments whose name begins with "test" such as testLifecycle, 
					testSingleUse, testStress, et al. To be sure that your calling interfaces are 
					well-defined, it is quite often a good practice to write the test classes 
					first, and then write the library code, i.e. to stub out the library calls, 
					then write the test class methods, and then go back and complete the library 
					code until all of the tests work. To run the test class(es), include the 
					TvaTestbed project in your Visual Studio .NET solution and set as the startup 
					project. That way, when you press F5 to run your code it will start the Testbed 
					application, which allows you to select the test-class DLL to execute from the 
					disk. Breakpoints et al work just fine using this method. When all of your 
					tests complete successfully, remove the TvaTestbed project from your solution 
					(do not delete it, just remove it from the solution!).
				</p>
			<LI>
				<a href="">Design-Time Components</a><P>
					The generic design-time component controller class is 
					System.ComponentModel.Design.ComponentDesigner; to access this class, you must 
					add a reference to System.Design.dll.
				</P>
			<LI>
				<a href="">ASP.NET</a>
			<LI>
				<a href="">Windows Forms</a><P>
					The DoEvents() function is buried in the namespaces as 
					System.Windows.Forms.Application.DoEvents()
				</P>
				<P>
					To display text in a multi-line text box or rich-text control, append the text 
					to the control's Text property, then scroll the control to the cursor position. 
					Note that the HideSelection property myst be set to False for this to work 
					correctly, e.g.<BR>
					<PRE>	Private Sub ShowStatus(ByVal sMsg As String)
		StatusTextBox.AppendText(sMsg &amp; vbCrLf)
		StatusTextBox.ScrollToCaret()		  'must set HideSelection property to False for this to work correctly
		System.Windows.Forms.Application.DoEvents()
	End Sub</PRE>
				<P></P>
			<LI>
				<a href="">Windows Forms Controls and Threading</a><P>
					Only the GUI thread may add or remove items from collections in GUI controls. For example, a background polling thread cannot directly add new TreeNode objects to a TreeView control.</p><p>To get around this, use a delegate and the Control's Invoke method; this will automatically marshall the objects to the control's thread and perform the requested alteration. For example:</P>
<PRE>	Public Class MyForm
		inherits System.Windows.Forms.Form

		...

		'this is a generic error-handling routine within the form
		Private Sub ShowError(ByRef ex As Exception)
			ShowMessage(ex.Message, True)
		End Sub

		'declare delegates for a cross-thread calls
		Protected Delegate Sub ShowErrorDelegate(ByRef ex As Exception)
		Protected Delegate Sub OnCancelAlarmDelegate(ByRef oAlarmProxy As SsamWatcher.SsamObjectInfo)
		Protected Delegate Sub OnRaiseAlarmDelegate(ByRef oAlarmProxy As SsamWatcher.SsamObjectInfo)

		'these subroutines handle events from a component running on its own thread
		Private Sub SsamAlarmWatcher1_HadError(ByRef ex As System.Exception) Handles SsamAlarmWatcher1.HadError
			'make an instance of the delegate
			Dim dlgt As New ShowErrorDelegate(AddressOf ShowError)
			'call the delegate passing an array of parameter values
			Invoke(dlgt, New Object() {ex})		  'ShowError(ex) via delegate to cross threads
		End Sub

		Private Sub SsamAlarmWatcher1_ClosedAlarm1(ByRef oAlarmProxy As SsamWatcher.SsamObjectInfo) Handles SsamAlarmWatcher1.ClosedAlarm
			Dim dlgt As New OnCancelAlarmDelegate(AddressOf OnCancelAlarm)
			Invoke(dlgt, New Object() {oAlarmProxy})	   'OnCancelAlarm(oAlarmProxy) via delegate to cross threads
		End Sub

		Private Sub SsamAlarmWatcher1_OpenedAlarm1(ByRef oAlarmProxy As SsamWatcher.SsamObjectInfo) Handles SsamAlarmWatcher1.OpenedAlarm
			Dim dlgt As New OnRaiseAlarmDelegate(AddressOf OnRaiseAlarm)
			Invoke(dlgt, New Object() {oAlarmProxy})	   'OnRaiseAlarm(oAlarmProxy) via delegate to cross threads
		End Sub

		...

	End Class</PRE>
				<P>Note: at first I used a delegate for the Add method of the TreeView class, because that is where the 'cannot call method across threads' exception occurred; the exception happened again later on the Remove method of the TreeView class. The lesson learned here is to push the cross-thread call as far back up the call-chain as possible, ideally in the handler for the entry point from the external (non-GUI) thread. That way the marshalling is done only once, there is only one delegate tied to the generating event instead of the destructive control methods eventually used, and since we have hopped over to the GUI's thread in the event handler, the code can do anything it likes to the GUI after that point.</P>
			<LI>
				<a href="">Windows Services</a>
			<LI>
				<a href="">ActiveX components</a>
				<UL>
					<LI>
						Addind a visual ActiveX component to a form can cause the "load" even not to 
						occure when calling it as a dialogue and other wierdness.
						<OL>
					<LI>
						Add the following code snippet to the form class to fix the problem:
						<BR>
						<PRE>Private Const WM_SHOWWINDOW = &amp;H18 <BR>Private m_loaded As Boolean <BR>Protected Overrides Sub WndProc(ByRef m As System.Windows.Forms.Message) <BR>	If m.Msg = WM_SHOWWINDOW Then <BR>		If Not m_loaded Then <BR>			MyBase.OnLoad(New System.EventArgs()) <BR>			m_loaded = True <BR>		End If <BR>	End If <BR>MyBase.WndProc(m) <BR>End Sub </PRE>
					</LI>
		</OL>
		</LI> </UL> </LI> </OL>
		<P></OL? LI <></P>
		<P>
			<A href="../index.html">Return</A>
		</P>
	</BODY>
</HTML>
